package main

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"
	_ "net/http/pprof"
	"unsafe"
)

func main() {

	go func() {
		http.ListenAndServe(":8080", nil)
	}()

	log.Println("Старт программы!")

	Данные, err := ПодготовитьДанныеИзФайла("data.json")
	if err != nil {
		log.Fatal(err)
	}

	РабочиеЦентры := Данные.РабочиеЦентры
	ГрафыОпераций := Данные.ГрафыОпераций

	КартаОперций := СоздатьКартуОпераций(&ГрафыОпераций)
	КартаРЦ := СоздатьКартуРЦ(&РабочиеЦентры)

	ДеревоЭтапов := ЗаполнитьДеревоЭтапов(&ГрафыОпераций)
	Пространство := СоздатьПространство(&РабочиеЦентры)

	ПриоритетыФинальныхЭтапов, Приоритеты := ЗаполнитьПриоритеты(ГрафыОпераций, ДеревоЭтапов)

	ЭтапыПотребители := make([]typeКлючЭтап, 0, len(*ДеревоЭтапов)*2)
	ОпределитьЭтапыПотребители(Приоритеты, ПриоритетыФинальныхЭтапов, &ЭтапыПотребители, ДеревоЭтапов)

	log.Println("Данные подготовленны!")

	ЗаполнитьПространство(Пространство, ЭтапыПотребители, КартаОперций, КартаРЦ, Приоритеты, ПриоритетыФинальныхЭтапов, ДеревоЭтапов)

	ЗаписатьПространствоВФайл(Пространство)

}

func ЗаполнитьПространство(Пространство map[string]*[]uint, ЭтапыПотребители []typeКлючЭтап, КартаОперций map[string][]typeГрафыОпераций, КартаРЦ map[string][]string, Приоритеты *[]int, ПриоритетыФинальныхЭтапов map[int]map[string]interface{}, ДеревоЭтапов *map[string]*typeВершина) {
	ПустаяДорожка := Пространство["Free"]

	for true {

		*ПустаяДорожка = append(*ПустаяДорожка, 0)
		ГраницаПространства := len(*ПустаяДорожка)
		_ = ГраницаПространства

		for index := range ЭтапыПотребители {

			Лист := ЭтапыПотребители[index].Этап
			Операции := КартаОперций[Лист.Этап]
			РЦ := КартаРЦ[Операции[0].ВидРабочегоЦентра]

			for rc := range РЦ {

				Дорожка := Пространство[РЦ[rc]]
				if len(*Дорожка) == ГраницаПространства {
					continue
				}

				ДополнитьДорожку(Дорожка, &ГраницаПространства, ПустаяДорожка)

				*Дорожка = append(*Дорожка, uint(Операции[0].КлючСтроки))
				КартаОперций[Лист.Этап][0].ПлановоеВремяВыполнения--

				if Операции[0].ПлановоеВремяВыполнения == 0 {
					КартаОперций[Лист.Этап] = append(Операции[0:0], Операции[1:]...)
					if len(КартаОперций[Лист.Этап]) == 0 {
						Лист.Удалить = true
					}
				}
				break
			}
		}

		ОпределитьЭтапыПотребители(Приоритеты, ПриоритетыФинальныхЭтапов, &ЭтапыПотребители, ДеревоЭтапов)

		if len(ЭтапыПотребители) <= 0 {
			log.Println("Выполнение завершено!")

			for _, Дорожка := range Пространство {
				ДополнитьДорожку(Дорожка, &ГраницаПространства, ПустаяДорожка)
			}
			log.Println("Пространство дополнено.")
			break
		}
	}
}

func ДополнитьДорожку(Дорожка *[]uint, ГраницаПространства *int, ПустаяДорожка *[]uint) {
	if len(*Дорожка) < *ГраницаПространства-1 {
		*Дорожка = append(*Дорожка, (*ПустаяДорожка)[len(*Дорожка):*ГраницаПространства-1]...)
	}
}

func ЗаписатьПространствоВФайл(Пространство map[string]*[]uint) {
	dataJSON, err := json.Marshal(Пространство)

	if err != nil {
		log.Fatal("JSON marshaling failed:", err)
	}
	const settingsFilename = "settings.json"
	err = ioutil.WriteFile(settingsFilename, dataJSON, 0)
	if err != nil {
		log.Fatal("Cannot write updated settings file:", err)
	}

	log.Println("Сохранение в файл завершено.")
}

func СоздатьКартуРЦ(РабочиеЦентры *[]typeРабочиеЦентры) map[string][]string {
	КартаРЦ := make(map[string][]string)
	for i := range *РабочиеЦентры {
		КартаРЦ[(*РабочиеЦентры)[i].ВидРабочегоЦентра] = append(КартаРЦ[(*РабочиеЦентры)[i].ВидРабочегоЦентра], (*РабочиеЦентры)[i].РабочийЦентр)
	}
	return КартаРЦ
}

func СоздатьКартуОпераций(ГрафыОпераций *[]typeГрафыОпераций) map[string][]typeГрафыОпераций {
	КартаОперций := make(map[string][]typeГрафыОпераций)
	for _, СтрокаОперации := range *ГрафыОпераций {
		n := КартаОперций[СтрокаОперации.Этап]
		КартаОперций[СтрокаОперации.Этап] = append(n, СтрокаОперации)
	}
	return КартаОперций
}

func ЗаполнитьПриоритеты(ГрафыОпераций []typeГрафыОпераций, ДеревоЭтапов *map[string]*typeВершина) (map[int]map[string]interface{}, *[]int) {
	var МаксПриоритет int

	ПриоритетыФинальныхЭтапов := make(map[int]map[string]interface{}, len(ГрафыОпераций))
	for i := range ГрафыОпераций {

		_, Ok := (*ДеревоЭтапов)[ГрафыОпераций[i].Этап]
		if !Ok {
			continue
		}

		Приоритет := ГрафыОпераций[i].Приоритет

		if МаксПриоритет < Приоритет {
			МаксПриоритет = Приоритет
		}
		_, Ok = ПриоритетыФинальныхЭтапов[Приоритет]
		if !Ok {
			ПриоритетыФинальныхЭтапов[Приоритет] = make(map[string]interface{}, 1)
		}
		ПриоритетыФинальныхЭтапов[Приоритет][ГрафыОпераций[i].Этап] = nil
	}

	Приоритеты := make([]int, 0, len(ПриоритетыФинальныхЭтапов))
	for i := МаксПриоритет; i >= 0; i-- {
		_, Ok := ПриоритетыФинальныхЭтапов[i]
		if !Ok {
			continue
		}
		Приоритеты = append(Приоритеты, i)
	}
	return ПриоритетыФинальныхЭтапов, &Приоритеты
}

func СоздатьПространство(РабочиеЦентры *[]typeРабочиеЦентры) map[string]*[]uint {
	Пространство := make(map[string]*[]uint)
	h := make([]uint, 0, 1000000)
	Пространство["Free"] = &h

	for i := range *РабочиеЦентры {
		h := make([]uint, 0, 1000000)
		Пространство[(*РабочиеЦентры)[i].РабочийЦентр] = &h
	}
	return Пространство
}

func ЗаполнитьДеревоЭтапов(g *[]typeГрафыОпераций) *map[string]*typeВершина {

	ДеревьяЭтапов := make(map[string]*typeВершина)
	ОбработанныеВершины := make(map[string]interface{})

	lv := 0
	f := *g
	for i := range f {

		_, Ok := ОбработанныеВершины[f[i].Этап]
		if Ok {
			continue
		}

		if f[i].Уровень == lv {
			Вершина := *new(typeВершина)
			Вершина.Этап = f[i].Этап
			ЗаполнитьПоследователи(lv+1, &Вершина, g, ОбработанныеВершины)
			ОбработанныеВершины[f[i].Этап] = nil
			ДеревьяЭтапов[f[i].Этап] = &Вершина
		}
	}
	return &ДеревьяЭтапов
}

func ЗаполнитьПоследователи(lv int, u *typeВершина, g *[]typeГрафыОпераций, ОбработанныеВершины map[string]interface{}) {
	f := *g
	for i := range *g {

		_, Ok := ОбработанныеВершины[f[i].Этап]
		if Ok {
			continue
		}

		if lv != f[i].Уровень {
			continue
		}
		if f[i].ЭтапПотребитель != u.Этап {
			continue
		}
		Вершина := *new(typeВершина)
		Вершина.Этап = f[i].Этап
		ЗаполнитьПоследователи(lv+1, &Вершина, g, ОбработанныеВершины)
		ОбработанныеВершины[f[i].Этап] = nil
		u.Последователи = append(u.Последователи, unsafe.Pointer(&Вершина))
	}
}

func ОпределитьЭтапыПотребители(Приоритеты *[]int, ПриоритетыФинальныхЭтапов map[int]map[string]interface{}, ЭтапыПотребители *[]typeКлючЭтап, ДеревоЭтапов *map[string]*typeВершина) {

	*ЭтапыПотребители = (*ЭтапыПотребители)[0:0]

	tr := *ДеревоЭтапов

	var Листья []*typeВершина
	var Лист *typeВершина

	for _, i := range *Приоритеты {
		_, Ok := ПриоритетыФинальныхЭтапов[i]
		if !Ok {
			continue
		}
		for ФинальныйЭтап := range ПриоритетыФинальныхЭтапов[i] {

			if tr[ФинальныйЭтап].Удалить {
				delete(*ДеревоЭтапов, ФинальныйЭтап)
				delete(ПриоритетыФинальныхЭтапов, i)
				continue
			}

			Лист = tr[ФинальныйЭтап]

			for i := 0; i < len(Лист.Последователи); i++ {
				if (*typeВершина)(Лист.Последователи[i]).Удалить {
					tr[ФинальныйЭтап].Последователи = append(Лист.Последователи[:i], Лист.Последователи[i+1:]...)
					i--
				}
			}

			if len(Лист.Последователи) == 0 {
				*ЭтапыПотребители = append(*ЭтапыПотребители, typeКлючЭтап{ФинальныйЭтап, Лист})
				continue
			}

			//Листья = make([]*typeВершина, 0, cap(Листья))
			Листья = Листья[0:0]
			ПолучитьЛистьяДерева(Лист, &Листья)
			if len(Листья) == 0 {
				panic("Ошибка!")
			}

			for _, g := range Листья {
				*ЭтапыПотребители = append(*ЭтапыПотребители, typeКлючЭтап{ФинальныйЭтап, g})
			}
		}
	}
}

func ПолучитьЛистьяДерева(Вершина *typeВершина, Листья *[]*typeВершина) *[]*typeВершина {

	for un := 0; un < len(Вершина.Последователи); un++ {
		l := (*typeВершина)(Вершина.Последователи[un])

		if l.Удалить {
			Вершина.Последователи = append(Вершина.Последователи[:un], Вершина.Последователи[un+1:]...)
			un--
			continue
		}

		if len(l.Последователи) == 0 {
			*Листья = append(*Листья, l)
			continue
		}

		ПолучитьЛистьяДерева(l, Листья)

		if len(l.Последователи) == 0 {
			*Листья = append(*Листья, l)
		}
	}

	//
	return Листья
}
